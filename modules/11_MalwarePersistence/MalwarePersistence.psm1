Set-StrictMode -Version Latest

if (-not (Get-Command New-ModuleResult -EA SilentlyContinue)) {
  Import-Module -Force -DisableNameChecking (Join-Path $PSScriptRoot '../../core/Contracts.psm1')
}
if (-not (Get-Command Write-Info -EA SilentlyContinue)) {
  Import-Module -Force -DisableNameChecking (Join-Path $PSScriptRoot '../../core/Utils.psm1')
}

$script:ModuleName       = 'MalwarePersistence'
$script:ApiUrl           = 'https://openrouter.ai/api/v1/chat/completions'
$script:ApiKeyEnvVar     = 'OPENROUTER_API_KEY'
$script:ScanDirectories  = @('C:\\Users', 'C:\\ProgramData')
$script:ScriptExtensions = @('.ps1','.psm1','.bat','.cmd','.vbs','.js','.jse','.hta','.py','.zip')

function Get-OpenRouterApiKey {
  $key = [System.Environment]::GetEnvironmentVariable($script:ApiKeyEnvVar)
  if (-not $key) { return '' }
  return $key
}

function Test-Ready {
  param($Context)

  if (-not (Get-OpenRouterApiKey)) {
    Write-Warn "OpenRouter API key is missing (set `$env:$($script:ApiKeyEnvVar)); cannot classify suspicious scripts."
    return $false
  }

  return $true
}

function Get-ScriptInventory {
  $collected = New-Object 'System.Collections.Generic.List[string]'

  foreach ($root in $script:ScanDirectories) {
    if ([string]::IsNullOrWhiteSpace($root)) { continue }
    if (-not (Test-Path -LiteralPath $root)) { continue }

    try {
      $items = Get-ChildItem -LiteralPath $root -File -Recurse -ErrorAction Stop
    } catch {
      Write-Warn ("Failed to enumerate {0}: {1}" -f $root, $_.Exception.Message)
      continue
    }

    foreach ($item in $items) {
      try {
        $ext = [System.IO.Path]::GetExtension($item.Name)
      } catch {
        $ext = ''
      }

      if (-not $ext) { continue }
      $extLower = $ext.ToLowerInvariant()
      if ($script:ScriptExtensions -contains $extLower) {
        if (-not $collected.Contains($item.FullName)) {
          $collected.Add($item.FullName) | Out-Null
        }
      }
    }
  }

  $unique = $collected | Sort-Object -Unique
  return @($unique)
}

function Build-AiRequest {
  param([string[]]$Inventory)

  $systemPrompt = @"
You are a Windows incident response assistant for CyberPatriot scoring.
Return ONLY a raw JSON array (no code fences) of absolute filesystem paths for script files that are malicious or suspicious persistence mechanisms which should be removed.
Only mark files that are clearly malicious, suspicious persistence, or not required for legitimate software operation.
If no files require removal, respond with [].
"@

  $inventoryArray = @($Inventory)
  $inventoryBlock = ($inventoryArray -join [Environment]::NewLine)
  $userPrompt = @"
You are reviewing script files collected from persistence-prone directories on a Windows system.

SCANNED FILES ($($inventoryArray.Count) entries):
$inventoryBlock

Identify the files that are malicious or suspicious and should be removed. Respond ONLY with a JSON array of paths.
"@

  $body = @{
    model       = 'openai/gpt-5'
    temperature = 0
    max_tokens  = 4000
    messages    = @(
      @{ role = 'system'; content = $systemPrompt },
      @{ role = 'user'; content = $userPrompt }
    )
  }

  return $body | ConvertTo-Json -Depth 6
}

function Invoke-Classification {
  param([string[]]$Inventory)

  $inventoryArray = @($Inventory)

  if (-not $inventoryArray -or $inventoryArray.Count -eq 0) {
    return @()
  }

  $bodyJson = Build-AiRequest -Inventory $inventoryArray

  $apiKey = Get-OpenRouterApiKey
  if (-not $apiKey) {
    throw 'OpenRouter API key was not available when classification was attempted.'
  }

  $headers = @{
    'Authorization' = "Bearer $apiKey"
    'Content-Type'  = 'application/json'
  }

  try {
    $response = Invoke-RestMethod -Uri $script:ApiUrl -Method Post -Headers $headers -Body $bodyJson -ErrorAction Stop
  } catch {
    throw ("OpenRouter API call failed: {0}" -f $_.Exception.Message)
  }

  $content = $response.choices[0].message.content
  if (-not $content) {
    throw 'OpenRouter returned an empty response.'
  }

  $content = $content -replace '^```json\s*', '' -replace '\s*```$',''

  try {
    $parsed = $content | ConvertFrom-Json
  } catch {
    throw ("Failed to parse OpenRouter response: {0}" -f $_.Exception.Message)
  }

  if ($parsed -isnot [System.Collections.IEnumerable]) {
    throw 'OpenRouter response was not an array.'
  }

  $paths = @()
  foreach ($item in $parsed) {
    if ($item -is [string]) {
      $value = $item.Trim()
      if ($value) { $paths += $value }
    }
  }

  return @($paths | Sort-Object -Unique)
}

function Get-NetworkListenerInventory {
  $connections = @()

  try {
    $listeners = Get-NetTCPConnection -State Listen -ErrorAction Stop |
      Sort-Object LocalPort |
      Select-Object LocalPort, OwningProcess,
        @{Name='ProcessName';Expression={
            (Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue).ProcessName
        }},
        @{Name='ExecutablePath';Expression={
            (Get-CimInstance Win32_Process -Filter "ProcessId=$($_.OwningProcess)" -ErrorAction SilentlyContinue).ExecutablePath
        }}

    foreach ($listener in $listeners) {
      if ($listener.ExecutablePath) {
        $connections += [pscustomobject]@{
          LocalPort      = $listener.LocalPort
          ProcessId      = $listener.OwningProcess
          ProcessName    = $listener.ProcessName
          ExecutablePath = $listener.ExecutablePath
        }
      }
    }
  } catch {
    Write-Warn ("Failed to enumerate network listeners: {0}" -f $_.Exception.Message)
  }

  return @($connections)
}

function Get-OutboundConnectionInventory {
  $connections = @()

  # Legitimate processes to exclude (common browsers, updaters, Windows services)
  $legitimateProcesses = @(
    'chrome.exe', 'firefox.exe', 'msedge.exe', 'iexplore.exe', 'brave.exe', 'opera.exe',
    'MicrosoftEdgeUpdate.exe', 'GoogleUpdate.exe', 'wuauclt.exe', 'UsoClient.exe', 'TrustedInstaller.exe',
    'svchost.exe', 'OneDrive.exe', 'Teams.exe', 'Skype.exe', 'Zoom.exe', 'slack.exe',
    'dropbox.exe', 'spotify.exe', 'discord.exe', 'steam.exe',
    'System', 'RuntimeBroker.exe', 'SearchIndexer.exe', 'dwm.exe', 'explorer.exe',
    'taskhostw.exe', 'taskhost.exe', 'spoolsv.exe', 'services.exe', 'csrss.exe', 'smss.exe',
    'lsass.exe', 'wininit.exe', 'winlogon.exe', 'conhost.exe'
  )

  # Legitimate paths to exclude (system directories for Microsoft-signed binaries)
  $legitimatePaths = @(
    'C:\Windows\System32\',
    'C:\Windows\SysWOW64\',
    'C:\Windows\explorer.exe',
    'C:\Program Files\Windows Defender\',
    'C:\Program Files\Microsoft Office\',
    'C:\Program Files (x86)\Microsoft\',
    'C:\Program Files\Microsoft'
  )

  try {
    # Get established and SynSent outbound connections
    $outbound = Get-NetTCPConnection -State Established, SynSent -ErrorAction Stop |
      Where-Object { $_.RemoteAddress -ne '127.0.0.1' -and $_.RemoteAddress -ne '::1' } |
      Sort-Object OwningProcess -Unique |
      Select-Object RemoteAddress, RemotePort, OwningProcess,
        @{Name='ProcessName';Expression={
            (Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue).ProcessName
        }},
        @{Name='ExecutablePath';Expression={
            (Get-CimInstance Win32_Process -Filter "ProcessId=$($_.OwningProcess)" -ErrorAction SilentlyContinue).ExecutablePath
        }},
        @{Name='CommandLine';Expression={
            (Get-CimInstance Win32_Process -Filter "ProcessId=$($_.OwningProcess)" -ErrorAction SilentlyContinue).CommandLine
        }}

    foreach ($conn in $outbound) {
      if (-not $conn.ExecutablePath) { continue }
      if (-not $conn.ProcessName) { continue }

      # Skip legitimate processes
      $processName = $conn.ProcessName + '.exe'
      if ($legitimateProcesses -contains $processName) { continue }

      # Skip legitimate paths
      $isLegitPath = $false
      foreach ($legitPath in $legitimatePaths) {
        if ($conn.ExecutablePath -like "$legitPath*") {
          $isLegitPath = $true
          break
        }
      }
      if ($isLegitPath) { continue }

      # Flag suspicious connections
      $connections += [pscustomobject]@{
        RemoteAddress   = $conn.RemoteAddress
        RemotePort      = $conn.RemotePort
        ProcessId       = $conn.OwningProcess
        ProcessName     = $conn.ProcessName
        ExecutablePath  = $conn.ExecutablePath
        CommandLine     = $conn.CommandLine
      }
    }
  } catch {
    Write-Warn ("Failed to enumerate outbound connections: {0}" -f $_.Exception.Message)
  }

  return @($connections)
}

function Get-RegistryRunKeys {
  $registryPaths = @(
    # HKLM paths
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\Run',
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce',
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunServices',
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce',
    'HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run',
    'HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Run',
    'HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce',

    # HKCU paths
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\Run',
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce',
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\RunServices',
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce',
    'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run'
  )

  $collected = @()

  foreach ($path in $registryPaths) {
    if (-not (Test-Path -LiteralPath $path -ErrorAction SilentlyContinue)) {
      continue
    }

    try {
      $entries = Get-ItemProperty -LiteralPath $path -ErrorAction Stop
      $properties = $entries.PSObject.Properties | Where-Object {
        $_.Name -notmatch '^PS(Path|ParentPath|ChildName|Provider|Drive)$'
      }

      foreach ($prop in $properties) {
        $collected += [pscustomobject]@{
          RegistryPath = $path
          ValueName    = $prop.Name
          ValueData    = $prop.Value
          Type         = 'RegistryRun'
        }
      }
    } catch {
      Write-Warn ("Failed to read registry path {0}: {1}" -f $path, $_.Exception.Message)
    }
  }

  return @($collected)
}

function Get-StartupFolders {
  $startupPaths = @(
    'C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup'
  )

  # Add per-user startup folders
  try {
    $userDirs = Get-ChildItem -Path 'C:\Users' -Directory -ErrorAction Stop
    foreach ($userDir in $userDirs) {
      $userStartup = Join-Path $userDir.FullName 'AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup'
      if (Test-Path -LiteralPath $userStartup) {
        $startupPaths += $userStartup
      }
    }
  } catch {
    Write-Warn ("Failed to enumerate user directories: {0}" -f $_.Exception.Message)
  }

  $collected = @()

  foreach ($path in $startupPaths) {
    if (-not (Test-Path -LiteralPath $path -ErrorAction SilentlyContinue)) {
      continue
    }

    try {
      $items = Get-ChildItem -LiteralPath $path -File -ErrorAction Stop
      foreach ($item in $items) {
        $collected += [pscustomobject]@{
          FilePath     = $item.FullName
          FileName     = $item.Name
          FolderPath   = $path
          Type         = 'StartupFolder'
        }
      }
    } catch {
      Write-Warn ("Failed to enumerate startup folder {0}: {1}" -f $path, $_.Exception.Message)
    }
  }

  return @($collected)
}

function Get-ScheduledTasksPersistence {
  $collected = @()

  try {
    $tasks = Get-ScheduledTask -ErrorAction Stop | Where-Object {
      $_.State -ne 'Disabled' -and $_.TaskPath -notmatch '^\\Microsoft\\'
    }

    foreach ($task in $tasks) {
      try {
        $taskInfo = Get-ScheduledTaskInfo -TaskName $task.TaskName -TaskPath $task.TaskPath -ErrorAction SilentlyContinue
        $actions = $task.Actions | Where-Object { $_.Execute }

        foreach ($action in $actions) {
          $executable = $action.Execute
          $arguments = $action.Arguments

          # Flag tasks that execute from suspicious locations
          if ($executable -match '(?i)(\\Users\\|\\ProgramData\\|\\Temp\\|\\AppData\\)') {
            $collected += [pscustomobject]@{
              TaskName     = $task.TaskName
              TaskPath     = $task.TaskPath
              Executable   = $executable
              Arguments    = $arguments
              State        = $task.State
              LastRunTime  = if ($taskInfo) { $taskInfo.LastRunTime } else { $null }
              Type         = 'ScheduledTask'
            }
          }
        }
      } catch {
        Write-Warn ("Failed to process task {0}: {1}" -f $task.TaskName, $_.Exception.Message)
      }
    }
  } catch {
    Write-Warn ("Failed to enumerate scheduled tasks: {0}" -f $_.Exception.Message)
  }

  return @($collected)
}

function Get-WmiPersistence {
  $collected = @()

  try {
    # Get event filters
    $filters = Get-WmiObject -Namespace 'root\subscription' -Class '__EventFilter' -ErrorAction Stop

    # Get event consumers
    $consumers = Get-WmiObject -Namespace 'root\subscription' -Class '__EventConsumer' -ErrorAction Stop

    # Get bindings
    $bindings = Get-WmiObject -Namespace 'root\subscription' -Class '__FilterToConsumerBinding' -ErrorAction Stop

    # Collect filters
    foreach ($filter in $filters) {
      # Skip default system filters
      if ($filter.Name -match '^(SCM Event Log Filter|BVTFilter)$') {
        continue
      }

      $collected += [pscustomobject]@{
        Name         = $filter.Name
        Query        = $filter.Query
        QueryLanguage = $filter.QueryLanguage
        Namespace    = $filter.EventNamespace
        ObjectType   = 'EventFilter'
        Type         = 'WMI'
      }
    }

    # Collect consumers
    foreach ($consumer in $consumers) {
      # Skip default system consumers
      if ($consumer.Name -match '^(SCM Event Log Consumer|BVTConsumer)$') {
        continue
      }

      $consumerType = $consumer.__CLASS
      $details = ''

      if ($consumerType -eq 'CommandLineEventConsumer') {
        $details = $consumer.CommandLineTemplate
      } elseif ($consumerType -eq 'ActiveScriptEventConsumer') {
        $details = "Script: $($consumer.ScriptingEngine) - $($consumer.ScriptText)"
      } else {
        $details = $consumerType
      }

      $collected += [pscustomobject]@{
        Name         = $consumer.Name
        ConsumerType = $consumerType
        Details      = $details
        ObjectType   = 'EventConsumer'
        Type         = 'WMI'
      }
    }

    # Collect bindings
    foreach ($binding in $bindings) {
      # Extract filter and consumer names from paths
      $filterName = ''
      $consumerName = ''

      if ($binding.Filter -match '__EventFilter\.Name="([^"]+)"') {
        $filterName = $Matches[1]
      }
      if ($binding.Consumer -match '\.Name="([^"]+)"') {
        $consumerName = $Matches[1]
      }

      # Skip default system bindings
      if ($filterName -match '^(SCM Event Log Filter|BVTFilter)$' -or
          $consumerName -match '^(SCM Event Log Consumer|BVTConsumer)$') {
        continue
      }

      $collected += [pscustomobject]@{
        FilterName   = $filterName
        ConsumerName = $consumerName
        FilterPath   = $binding.Filter
        ConsumerPath = $binding.Consumer
        ObjectType   = 'Binding'
        Type         = 'WMI'
      }
    }
  } catch {
    Write-Warn ("Failed to enumerate WMI persistence: {0}" -f $_.Exception.Message)
  }

  return @($collected)
}

function Build-RegistryAiRequest {
  param([array]$RegistryEntries)

  $systemPrompt = @"
You are a Windows incident response assistant for CyberPatriot scoring.
Return ONLY a raw JSON array (no code fences) of objects identifying malicious or suspicious registry run key entries that should be removed.
Each object should have: {"RegistryPath": "path", "ValueName": "name", "Reason": "explanation"}.

CRITICAL DETECTION GUIDELINES:
- Flag ANY entry pointing to executables in suspicious locations: user directories, temp folders, ProgramData (unless clearly legitimate software)
- Flag entries with obfuscated or encoded commands (base64, PowerShell download cradles, etc.)
- Flag entries pointing to renamed system utilities (cmd.exe copies, powershell.exe copies, etc.)
- Flag entries with suspicious names (random characters, system-like names but wrong location)
- Flag entries executing scripts (.vbs, .js, .ps1, .bat, .cmd) from user-writable locations
- DO NOT flag legitimate software vendors (Microsoft, Adobe, Google, Dell, HP, Intel, NVIDIA, AMD, etc.)
- DO NOT flag standard Windows components in their proper locations (C:\Windows\System32, C:\Program Files)
- When in doubt about legitimacy, FLAG IT - false positives are acceptable in CyberPatriot

Common legitimate registry entries to IGNORE:
- OneDrive, SecurityHealth, Windows Defender, VMware Tools, VirtualBox, Teams, Skype, Zoom
- Standard driver/hardware utilities in proper Program Files locations
- Windows Update, Task Manager, System Restore entries

If no entries are suspicious, respond with [].
"@

  $entriesBlock = ($RegistryEntries | ForEach-Object {
    "Path: $($_.RegistryPath) | Name: $($_.ValueName) | Data: $($_.ValueData)"
  }) -join [Environment]::NewLine

  $userPrompt = @"
You are reviewing Windows registry run key entries for malicious persistence mechanisms.

REGISTRY RUN KEY ENTRIES ($($RegistryEntries.Count) entries):
$entriesBlock

Identify suspicious entries that may be malware persistence. Respond ONLY with a JSON array.
"@

  $body = @{
    model       = 'openai/gpt-5'
    temperature = 0
    max_tokens  = 4000
    messages    = @(
      @{ role = 'system'; content = $systemPrompt },
      @{ role = 'user'; content = $userPrompt }
    )
  }

  return $body | ConvertTo-Json -Depth 6
}

function Invoke-RegistryClassification {
  param([array]$RegistryEntries)

  if (-not $RegistryEntries -or $RegistryEntries.Count -eq 0) {
    return @()
  }

  $bodyJson = Build-RegistryAiRequest -RegistryEntries $RegistryEntries

  $apiKey = Get-OpenRouterApiKey
  if (-not $apiKey) {
    throw 'OpenRouter API key was not available when classification was attempted.'
  }

  $headers = @{
    'Authorization' = "Bearer $apiKey"
    'Content-Type'  = 'application/json'
  }

  try {
    $response = Invoke-RestMethod -Uri $script:ApiUrl -Method Post -Headers $headers -Body $bodyJson -ErrorAction Stop
  } catch {
    throw ("OpenRouter API call failed: {0}" -f $_.Exception.Message)
  }

  $content = $response.choices[0].message.content
  if (-not $content) {
    throw 'OpenRouter returned an empty response.'
  }

  $content = $content -replace '^```json\s*', '' -replace '\s*```$',''

  try {
    $parsed = $content | ConvertFrom-Json
  } catch {
    throw ("Failed to parse OpenRouter response: {0}" -f $_.Exception.Message)
  }

  if ($parsed -isnot [System.Collections.IEnumerable]) {
    throw 'OpenRouter response was not an array.'
  }

  return @($parsed)
}

function Build-StartupAiRequest {
  param([array]$StartupItems)

  $systemPrompt = @"
You are a Windows incident response assistant for CyberPatriot scoring.
Return ONLY a raw JSON array (no code fences) of objects identifying malicious or suspicious startup folder items that should be removed.
Each object should have: {"FilePath": "path", "Reason": "explanation"}.

CRITICAL DETECTION GUIDELINES:
- Flag ANY executable or script in startup folders unless it's clearly legitimate software
- Flag files with suspicious names (random characters, generic names like "update.exe", "svchost.exe", etc.)
- Flag all script files (.vbs, .js, .ps1, .bat, .cmd, .hta) unless clearly from legitimate vendors
- Flag shortcuts pointing to suspicious locations (user directories, temp folders, etc.)
- DO NOT flag legitimate software (Microsoft, Adobe, Google, Dell, HP, etc.)
- When in doubt, FLAG IT - false positives are acceptable in CyberPatriot

Common legitimate startup items to IGNORE:
- OneDrive, Teams, Skype, Zoom, Slack
- Hardware utilities from known vendors in proper Program Files locations
- Security software from known vendors

If no items are suspicious, respond with [].
"@

  $itemsBlock = ($StartupItems | ForEach-Object {
    "File: $($_.FileName) | Path: $($_.FilePath) | Folder: $($_.FolderPath)"
  }) -join [Environment]::NewLine

  $userPrompt = @"
You are reviewing Windows startup folder items for malicious persistence mechanisms.

STARTUP FOLDER ITEMS ($($StartupItems.Count) entries):
$itemsBlock

Identify suspicious items that may be malware persistence. Respond ONLY with a JSON array.
"@

  $body = @{
    model       = 'openai/gpt-5'
    temperature = 0
    max_tokens  = 4000
    messages    = @(
      @{ role = 'system'; content = $systemPrompt },
      @{ role = 'user'; content = $userPrompt }
    )
  }

  return $body | ConvertTo-Json -Depth 6
}

function Invoke-StartupClassification {
  param([array]$StartupItems)

  if (-not $StartupItems -or $StartupItems.Count -eq 0) {
    return @()
  }

  $bodyJson = Build-StartupAiRequest -StartupItems $StartupItems

  $apiKey = Get-OpenRouterApiKey
  if (-not $apiKey) {
    throw 'OpenRouter API key was not available when classification was attempted.'
  }

  $headers = @{
    'Authorization' = "Bearer $apiKey"
    'Content-Type'  = 'application/json'
  }

  try {
    $response = Invoke-RestMethod -Uri $script:ApiUrl -Method Post -Headers $headers -Body $bodyJson -ErrorAction Stop
  } catch {
    throw ("OpenRouter API call failed: {0}" -f $_.Exception.Message)
  }

  $content = $response.choices[0].message.content
  if (-not $content) {
    throw 'OpenRouter returned an empty response.'
  }

  $content = $content -replace '^```json\s*', '' -replace '\s*```$',''

  try {
    $parsed = $content | ConvertFrom-Json
  } catch {
    throw ("Failed to parse OpenRouter response: {0}" -f $_.Exception.Message)
  }

  if ($parsed -isnot [System.Collections.IEnumerable]) {
    throw 'OpenRouter response was not an array.'
  }

  return @($parsed)
}

function Build-ScheduledTaskAiRequest {
  param([array]$Tasks)

  $systemPrompt = @"
You are a Windows incident response assistant for CyberPatriot scoring.
Return ONLY a raw JSON array (no code fences) of objects identifying malicious or suspicious scheduled tasks that should be removed.
Each object should have: {"TaskName": "name", "TaskPath": "path", "Reason": "explanation"}.

CRITICAL DETECTION GUIDELINES:
- Flag ALL tasks executing from user directories, temp folders, or ProgramData (unless clearly legitimate)
- Flag tasks with suspicious names (random characters, generic system names, etc.)
- Flag tasks executing scripts (.vbs, .js, .ps1, .bat, .cmd) from user-writable locations
- Flag tasks with unusual execution patterns (frequent runs, persistence mechanisms)
- DO NOT flag legitimate software update tasks from known vendors (Microsoft, Adobe, Google, etc.)
- DO NOT flag standard Windows maintenance tasks in \Microsoft\ path
- When in doubt, FLAG IT - false positives are acceptable in CyberPatriot

Common legitimate scheduled tasks to IGNORE:
- Tasks in \Microsoft\ path (already filtered out)
- Google Update, Adobe Updater, Java Update (if in proper Program Files)
- Known security software scheduled scans

If no tasks are suspicious, respond with [].
"@

  $tasksBlock = ($Tasks | ForEach-Object {
    "Task: $($_.TaskPath)$($_.TaskName) | Executable: $($_.Executable) | Args: $($_.Arguments) | State: $($_.State)"
  }) -join [Environment]::NewLine

  $userPrompt = @"
You are reviewing Windows scheduled tasks for malicious persistence mechanisms.

SCHEDULED TASKS ($($Tasks.Count) entries):
$tasksBlock

Identify suspicious tasks that may be malware persistence. Respond ONLY with a JSON array.
"@

  $body = @{
    model       = 'openai/gpt-5'
    temperature = 0
    max_tokens  = 4000
    messages    = @(
      @{ role = 'system'; content = $systemPrompt },
      @{ role = 'user'; content = $userPrompt }
    )
  }

  return $body | ConvertTo-Json -Depth 6
}

function Invoke-ScheduledTaskClassification {
  param([array]$Tasks)

  if (-not $Tasks -or $Tasks.Count -eq 0) {
    return @()
  }

  $bodyJson = Build-ScheduledTaskAiRequest -Tasks $Tasks

  $apiKey = Get-OpenRouterApiKey
  if (-not $apiKey) {
    throw 'OpenRouter API key was not available when classification was attempted.'
  }

  $headers = @{
    'Authorization' = "Bearer $apiKey"
    'Content-Type'  = 'application/json'
  }

  try {
    $response = Invoke-RestMethod -Uri $script:ApiUrl -Method Post -Headers $headers -Body $bodyJson -ErrorAction Stop
  } catch {
    throw ("OpenRouter API call failed: {0}" -f $_.Exception.Message)
  }

  $content = $response.choices[0].message.content
  if (-not $content) {
    throw 'OpenRouter returned an empty response.'
  }

  $content = $content -replace '^```json\s*', '' -replace '\s*```$',''

  try {
    $parsed = $content | ConvertFrom-Json
  } catch {
    throw ("Failed to parse OpenRouter response: {0}" -f $_.Exception.Message)
  }

  if ($parsed -isnot [System.Collections.IEnumerable]) {
    throw 'OpenRouter response was not an array.'
  }

  return @($parsed)
}

function Build-WmiAiRequest {
  param([array]$WmiItems)

  $systemPrompt = @"
You are a Windows incident response assistant for CyberPatriot scoring.
Return ONLY a raw JSON array (no code fences) of objects identifying malicious or suspicious WMI persistence mechanisms that should be removed.
Each object should have: {"Name": "name", "ObjectType": "type", "Reason": "explanation"}.

CRITICAL DETECTION GUIDELINES:
- WMI persistence is EXTREMELY rare in legitimate software - flag anything not obviously system-related
- Flag ALL custom event filters, consumers, and bindings unless clearly from known security software
- Flag any CommandLineEventConsumer executing from suspicious locations
- Flag any ActiveScriptEventConsumer (script-based consumers are highly suspicious)
- Common legitimate exceptions: SCM Event Log Filter/Consumer, BVTFilter/Consumer (already filtered)
- When in doubt, FLAG IT - WMI persistence is a strong indicator of advanced malware

If no items are suspicious, respond with [].
"@

  $wmiBlock = ($WmiItems | ForEach-Object {
    if ($_.ObjectType -eq 'EventFilter') {
      "Filter: $($_.Name) | Query: $($_.Query) | Language: $($_.QueryLanguage)"
    } elseif ($_.ObjectType -eq 'EventConsumer') {
      "Consumer: $($_.Name) | Type: $($_.ConsumerType) | Details: $($_.Details)"
    } elseif ($_.ObjectType -eq 'Binding') {
      "Binding: $($_.FilterName) -> $($_.ConsumerName)"
    }
  }) -join [Environment]::NewLine

  $userPrompt = @"
You are reviewing WMI persistence mechanisms for malicious activity.

WMI PERSISTENCE ITEMS ($($WmiItems.Count) entries):
$wmiBlock

Identify suspicious WMI persistence that may be malware. Respond ONLY with a JSON array.
"@

  $body = @{
    model       = 'openai/gpt-5'
    temperature = 0
    max_tokens  = 4000
    messages    = @(
      @{ role = 'system'; content = $systemPrompt },
      @{ role = 'user'; content = $userPrompt }
    )
  }

  return $body | ConvertTo-Json -Depth 6
}

function Invoke-WmiClassification {
  param([array]$WmiItems)

  if (-not $WmiItems -or $WmiItems.Count -eq 0) {
    return @()
  }

  $bodyJson = Build-WmiAiRequest -WmiItems $WmiItems

  $apiKey = Get-OpenRouterApiKey
  if (-not $apiKey) {
    throw 'OpenRouter API key was not available when classification was attempted.'
  }

  $headers = @{
    'Authorization' = "Bearer $apiKey"
    'Content-Type'  = 'application/json'
  }

  try {
    $response = Invoke-RestMethod -Uri $script:ApiUrl -Method Post -Headers $headers -Body $bodyJson -ErrorAction Stop
  } catch {
    throw ("OpenRouter API call failed: {0}" -f $_.Exception.Message)
  }

  $content = $response.choices[0].message.content
  if (-not $content) {
    throw 'OpenRouter returned an empty response.'
  }

  $content = $content -replace '^```json\s*', '' -replace '\s*```$',''

  try {
    $parsed = $content | ConvertFrom-Json
  } catch {
    throw ("Failed to parse OpenRouter response: {0}" -f $_.Exception.Message)
  }

  if ($parsed -isnot [System.Collections.IEnumerable]) {
    throw 'OpenRouter response was not an array.'
  }

  return @($parsed)
}

function Build-NetworkAiRequest {
  param([array]$Connections)

  $systemPrompt = @"
You are a Windows incident response assistant for CyberPatriot scoring.
Return ONLY a raw JSON array (no code fences) of objects identifying suspicious listening network connections that may be backdoors or malware.
Each object should have: {"ExecutablePath": "path", "Reason": "explanation"}.

CRITICAL: In CyberPatriot, ANY non-default Windows listening process is suspicious except CCSclient.
- Flag ANY executable in System32 that is not a standard Windows service (backdoors like netcat are often renamed to innocent names like "exportfile.exe", "update.exe", "svchost32.exe", etc.)
- Flag ANY listening processes from user directories, temp folders, or unusual locations
- Flag processes with generic/suspicious names even if they don't match known malware signatures
- Do NOT rely on filename alone - attackers rename tools to evade detection
- The ONLY exception is CCSclient - do not flag it
- When in doubt, FLAG IT for manual review - false positives are acceptable in CyberPatriot context

Standard Windows services that should NOT be flagged include: svchost.exe, System, lsass.exe, spoolsv.exe, services.exe, wininit.exe, csrss.exe, smss.exe, dwm.exe, taskhost.exe, taskhostw.exe, SearchIndexer.exe, explorer.exe, RuntimeBroker.exe
Any executable not in this list or CCSclient should be considered suspicious.

If no connections are suspicious, respond with [].
"@

  $connectionsBlock = ($Connections | ForEach-Object {
    "Port: $($_.LocalPort) | PID: $($_.ProcessId) | Process: $($_.ProcessName) | Path: $($_.ExecutablePath)"
  }) -join [Environment]::NewLine

  $userPrompt = @"
You are reviewing listening network connections on a Windows system for potential backdoors or malware.

LISTENING CONNECTIONS ($($Connections.Count) entries):
$connectionsBlock

Identify suspicious connections that may be backdoors or malware. Respond ONLY with a JSON array.
"@

  $body = @{
    model       = 'openai/gpt-5'
    temperature = 0
    max_tokens  = 4000
    messages    = @(
      @{ role = 'system'; content = $systemPrompt },
      @{ role = 'user'; content = $userPrompt }
    )
  }

  return $body | ConvertTo-Json -Depth 6
}

function Invoke-NetworkListenerClassification {
  param([array]$Connections)

  if (-not $Connections -or $Connections.Count -eq 0) {
    return @()
  }

  $bodyJson = Build-NetworkAiRequest -Connections $Connections

  $apiKey = Get-OpenRouterApiKey
  if (-not $apiKey) {
    throw 'OpenRouter API key was not available when classification was attempted.'
  }

  $headers = @{
    'Authorization' = "Bearer $apiKey"
    'Content-Type'  = 'application/json'
  }

  try {
    $response = Invoke-RestMethod -Uri $script:ApiUrl -Method Post -Headers $headers -Body $bodyJson -ErrorAction Stop
  } catch {
    throw ("OpenRouter API call failed: {0}" -f $_.Exception.Message)
  }

  $content = $response.choices[0].message.content
  if (-not $content) {
    throw 'OpenRouter returned an empty response.'
  }

  $content = $content -replace '^```json\s*', '' -replace '\s*```$',''

  try {
    $parsed = $content | ConvertFrom-Json
  } catch {
    throw ("Failed to parse OpenRouter response: {0}" -f $_.Exception.Message)
  }

  if ($parsed -isnot [System.Collections.IEnumerable]) {
    throw 'OpenRouter response was not an array.'
  }

  return @($parsed)
}

function Build-OutboundConnectionAiRequest {
  param([array]$Connections)

  $systemPrompt = @"
You are a Windows incident response assistant for CyberPatriot scoring.
Return ONLY a raw JSON array (no code fences) of objects identifying suspicious outbound network connections that may be reverse shells, C2 beacons, or backdoors.
Each object should have: {"ExecutablePath": "path", "Reason": "explanation"}.

CRITICAL DETECTION GUIDELINES - OUTBOUND BACKDOOR DETECTION:
This is a second-pass scan for OUTBOUND/REVERSE backdoors (not listening servers). You're looking for:

1. REVERSE SHELLS: Executables making outbound connections to non-standard ports
   - Flag ANY executable in user directories (C:\Users\, AppData\, Downloads\, Desktop\, Documents\)
   - Flag ANY executable in temp directories (C:\Temp\, C:\Windows\Temp\, AppData\Local\Temp\)
   - Flag ANY executable in ProgramData or other writable locations
   - Common indicators: cmd.exe, powershell.exe, or nc.exe connections, especially to high ports

2. C2 BEACONS: Non-Microsoft signed executables making persistent connections
   - Flag executables in suspicious locations making HTTPS (443) or HTTP (80) connections
   - Flag executables with generic/random names connecting out
   - Flag renamed system utilities (like nc.exe renamed to update.exe)

3. SUSPICIOUS PATTERNS:
   - Connections to unusual ports (not 80/443/53) from non-browser processes
   - Scripts (PowerShell, Python, etc.) making network connections from user directories
   - Executables with obfuscated or suspicious command-line arguments
   - Connections from portable executables in writable locations

4. LEGITIMATE EXCLUSIONS (already filtered, but verify):
   - Standard browsers and their updaters (already excluded)
   - Windows Update and Microsoft services (already excluded)
   - Known legitimate software in Program Files (already excluded)

5. IMPORTANT NOTES:
   - This is AFTER filtering out obvious legitimate processes
   - When executables are in user-writable locations, they're HIGHLY suspicious
   - Non-Microsoft-signed executables making outbound connections = RED FLAG
   - When in doubt, FLAG IT - false positives are acceptable in CyberPatriot

If no connections are suspicious, respond with [].
"@

  $connectionsBlock = ($Connections | ForEach-Object {
    "Remote: $($_.RemoteAddress):$($_.RemotePort) | PID: $($_.ProcessId) | Process: $($_.ProcessName) | Path: $($_.ExecutablePath) | CmdLine: $($_.CommandLine)"
  }) -join [Environment]::NewLine

  $userPrompt = @"
You are reviewing OUTBOUND network connections (Established/SynSent state) on a Windows system for potential reverse shells, C2 beacons, or backdoors.

IMPORTANT: These are NOT listening servers - they are outbound connections that have already bypassed basic legitimacy filters.

OUTBOUND CONNECTIONS ($($Connections.Count) entries):
$connectionsBlock

Identify suspicious outbound connections that may be backdoors, reverse shells, or C2 beacons. Respond ONLY with a JSON array.
"@

  $body = @{
    model       = 'openai/gpt-5'
    temperature = 0
    max_tokens  = 4000
    messages    = @(
      @{ role = 'system'; content = $systemPrompt },
      @{ role = 'user'; content = $userPrompt }
    )
  }

  return $body | ConvertTo-Json -Depth 6
}

function Invoke-OutboundConnectionClassification {
  param([array]$Connections)

  if (-not $Connections -or $Connections.Count -eq 0) {
    return @()
  }

  $bodyJson = Build-OutboundConnectionAiRequest -Connections $Connections

  $apiKey = Get-OpenRouterApiKey
  if (-not $apiKey) {
    throw 'OpenRouter API key was not available when classification was attempted.'
  }

  $headers = @{
    'Authorization' = "Bearer $apiKey"
    'Content-Type'  = 'application/json'
  }

  try {
    $response = Invoke-RestMethod -Uri $script:ApiUrl -Method Post -Headers $headers -Body $bodyJson -ErrorAction Stop
  } catch {
    throw ("OpenRouter API call failed: {0}" -f $_.Exception.Message)
  }

  $content = $response.choices[0].message.content
  if (-not $content) {
    throw 'OpenRouter returned an empty response.'
  }

  $content = $content -replace '^```json\s*', '' -replace '\s*```$',''

  try {
    $parsed = $content | ConvertFrom-Json
  } catch {
    throw ("Failed to parse OpenRouter response: {0}" -f $_.Exception.Message)
  }

  if ($parsed -isnot [System.Collections.IEnumerable]) {
    throw 'OpenRouter response was not an array.'
  }

  return @($parsed)
}

function Invoke-MalwareAssessment {
  param([switch]$Remove)

  # ===== COLLECTION PHASE =====
  Write-Info 'Enumerating potential persistence scripts'
  $inventory = Get-ScriptInventory
  $inventoryArray = @($inventory)
  $inventoryCount = $inventoryArray.Count
  Write-Info ("Collected {0} script file(s)" -f $inventoryCount)

  Write-Info 'Enumerating listening network connections'
  $networkConnections = Get-NetworkListenerInventory
  $networkCount = $networkConnections.Count
  Write-Info ("Collected {0} listening connection(s)" -f $networkCount)

  Write-Info 'Enumerating outbound network connections'
  $outboundConnections = Get-OutboundConnectionInventory
  $outboundCount = $outboundConnections.Count
  Write-Info ("Collected {0} suspicious outbound connection(s)" -f $outboundCount)

  Write-Info 'Enumerating registry run keys'
  $registryEntries = Get-RegistryRunKeys
  $registryCount = $registryEntries.Count
  Write-Info ("Collected {0} registry run key(s)" -f $registryCount)

  Write-Info 'Enumerating startup folder items'
  $startupItems = Get-StartupFolders
  $startupCount = $startupItems.Count
  Write-Info ("Collected {0} startup item(s)" -f $startupCount)

  Write-Info 'Enumerating scheduled tasks'
  $scheduledTasks = Get-ScheduledTasksPersistence
  $tasksCount = $scheduledTasks.Count
  Write-Info ("Collected {0} suspicious scheduled task(s)" -f $tasksCount)

  Write-Info 'Enumerating WMI persistence'
  $wmiItems = Get-WmiPersistence
  $wmiCount = $wmiItems.Count
  Write-Info ("Collected {0} WMI persistence item(s)" -f $wmiCount)

  # Early exit if nothing found
  if ($inventoryCount -eq 0 -and $networkCount -eq 0 -and $outboundCount -eq 0 -and $registryCount -eq 0 -and
      $startupCount -eq 0 -and $tasksCount -eq 0 -and $wmiCount -eq 0) {
    Write-Info 'No persistence mechanisms found'
    return [pscustomobject]@{
      InventoryCount     = 0
      NetworkCount       = 0
      OutboundCount      = 0
      RegistryCount      = 0
      StartupCount       = 0
      TasksCount         = 0
      WmiCount           = 0
      Flagged            = @()
      FlaggedNetwork     = @()
      FlaggedOutbound    = @()
      FlaggedRegistry    = @()
      FlaggedStartup     = @()
      FlaggedTasks       = @()
      FlaggedWmi         = @()
      Removed            = @()
      RemovedNetwork     = @()
      RemovedOutbound    = @()
      RemovedRegistry    = @()
      RemovedStartup     = @()
      RemovedTasks       = @()
      RemovedWmi         = @()
      Declined           = @()
      DeclinedNetwork    = @()
      DeclinedOutbound   = @()
      DeclinedRegistry   = @()
      DeclinedStartup    = @()
      DeclinedTasks      = @()
      DeclinedWmi        = @()
    }
  }

  # ===== AI CLASSIFICATION PHASE =====
  # Process script files
  $flaggedArray = @()
  if ($inventoryCount -gt 0) {
    Write-Info 'Requesting AI analysis for scripts from OpenRouter'
    $flagged = Invoke-Classification -Inventory $inventoryArray
    $flaggedArray = @($flagged)
  }

  # Process network connections
  $flaggedNetworkArray = @()
  if ($networkCount -gt 0) {
    Write-Info 'Requesting AI analysis for network connections from OpenRouter'
    $flaggedNetwork = Invoke-NetworkListenerClassification -Connections $networkConnections
    $flaggedNetworkArray = @($flaggedNetwork)
  }

  # Process outbound connections
  $flaggedOutboundArray = @()
  if ($outboundCount -gt 0) {
    Write-Info 'Requesting AI analysis for outbound connections from OpenRouter'
    $flaggedOutbound = Invoke-OutboundConnectionClassification -Connections $outboundConnections
    $flaggedOutboundArray = @($flaggedOutbound)
  }

  # Process registry entries
  $flaggedRegistryArray = @()
  if ($registryCount -gt 0) {
    Write-Info 'Requesting AI analysis for registry run keys from OpenRouter'
    $flaggedRegistry = Invoke-RegistryClassification -RegistryEntries $registryEntries
    $flaggedRegistryArray = @($flaggedRegistry)
  }

  # Process startup items
  $flaggedStartupArray = @()
  if ($startupCount -gt 0) {
    Write-Info 'Requesting AI analysis for startup items from OpenRouter'
    $flaggedStartup = Invoke-StartupClassification -StartupItems $startupItems
    $flaggedStartupArray = @($flaggedStartup)
  }

  # Process scheduled tasks
  $flaggedTasksArray = @()
  if ($tasksCount -gt 0) {
    Write-Info 'Requesting AI analysis for scheduled tasks from OpenRouter'
    $flaggedTasks = Invoke-ScheduledTaskClassification -Tasks $scheduledTasks
    $flaggedTasksArray = @($flaggedTasks)
  }

  # Process WMI persistence
  $flaggedWmiArray = @()
  if ($wmiCount -gt 0) {
    Write-Info 'Requesting AI analysis for WMI persistence from OpenRouter'
    $flaggedWmi = Invoke-WmiClassification -WmiItems $wmiItems
    $flaggedWmiArray = @($flaggedWmi)
  }

  # Check if anything was flagged
  $totalFlagged = $flaggedArray.Count + $flaggedNetworkArray.Count + $flaggedOutboundArray.Count + $flaggedRegistryArray.Count +
                  $flaggedStartupArray.Count + $flaggedTasksArray.Count + $flaggedWmiArray.Count

  if ($totalFlagged -eq 0) {
    Write-Info 'AI did not flag any items for removal'
    return [pscustomobject]@{
      InventoryCount     = $inventoryCount
      NetworkCount       = $networkCount
      OutboundCount      = $outboundCount
      RegistryCount      = $registryCount
      StartupCount       = $startupCount
      TasksCount         = $tasksCount
      WmiCount           = $wmiCount
      Flagged            = @()
      FlaggedNetwork     = @()
      FlaggedOutbound    = @()
      FlaggedRegistry    = @()
      FlaggedStartup     = @()
      FlaggedTasks       = @()
      FlaggedWmi         = @()
      Removed            = @()
      RemovedNetwork     = @()
      RemovedOutbound    = @()
      RemovedRegistry    = @()
      RemovedStartup     = @()
      RemovedTasks       = @()
      RemovedWmi         = @()
      Declined           = @()
      DeclinedNetwork    = @()
      DeclinedOutbound   = @()
      DeclinedRegistry   = @()
      DeclinedStartup    = @()
      DeclinedTasks      = @()
      DeclinedWmi        = @()
    }
  }

  # ===== DISPLAY PHASE =====
  # Display flagged scripts
  if ($flaggedArray.Count -gt 0) {
    Write-Info 'AI flagged the following script paths for review:'
    foreach ($path in $flaggedArray) {
      Write-Host ("  - {0}" -f $path)
    }
  }

  # Display flagged network connections
  if ($flaggedNetworkArray.Count -gt 0) {
    Write-Info 'AI flagged the following network connections as suspicious:'
    foreach ($item in $flaggedNetworkArray) {
      Write-Host ("  - {0} (Reason: {1})" -f $item.ExecutablePath, $item.Reason)
    }
  }

  # Display flagged outbound connections
  if ($flaggedOutboundArray.Count -gt 0) {
    Write-Info 'AI flagged the following outbound connections as suspicious:'
    foreach ($item in $flaggedOutboundArray) {
      Write-Host ("  - {0} (Reason: {1})" -f $item.ExecutablePath, $item.Reason)
    }
  }

  # Display flagged registry entries
  if ($flaggedRegistryArray.Count -gt 0) {
    Write-Info 'AI flagged the following registry run keys as suspicious:'
    foreach ($item in $flaggedRegistryArray) {
      Write-Host ("  - {0}\{1} = {2} (Reason: {3})" -f $item.RegistryPath, $item.ValueName,
                  ($registryEntries | Where-Object { $_.RegistryPath -eq $item.RegistryPath -and $_.ValueName -eq $item.ValueName } | Select-Object -First 1).ValueData,
                  $item.Reason)
    }
  }

  # Display flagged startup items
  if ($flaggedStartupArray.Count -gt 0) {
    Write-Info 'AI flagged the following startup items as suspicious:'
    foreach ($item in $flaggedStartupArray) {
      Write-Host ("  - {0} (Reason: {1})" -f $item.FilePath, $item.Reason)
    }
  }

  # Display flagged scheduled tasks
  if ($flaggedTasksArray.Count -gt 0) {
    Write-Info 'AI flagged the following scheduled tasks as suspicious:'
    foreach ($item in $flaggedTasksArray) {
      Write-Host ("  - {0}{1} (Reason: {2})" -f $item.TaskPath, $item.TaskName, $item.Reason)
    }
  }

  # Display flagged WMI items
  if ($flaggedWmiArray.Count -gt 0) {
    Write-Info 'AI flagged the following WMI persistence items as suspicious:'
    foreach ($item in $flaggedWmiArray) {
      Write-Host ("  - {0} ({1}) (Reason: {2})" -f $item.Name, $item.ObjectType, $item.Reason)
    }
  }

  # ===== REMOVAL PHASE =====
  $removed = @()
  $declined = @()
  $removedNetwork = @()
  $declinedNetwork = @()
  $removedOutbound = @()
  $declinedOutbound = @()
  $removedRegistry = @()
  $declinedRegistry = @()
  $removedStartup = @()
  $declinedStartup = @()
  $removedTasks = @()
  $declinedTasks = @()
  $removedWmi = @()
  $declinedWmi = @()

  if ($Remove) {
    # Handle script removals
    foreach ($path in $flaggedArray) {
      $confirmation = Read-Host ("Remove flagged script path? (Y/N, default Y): `"$path`"")
      if ([string]::IsNullOrWhiteSpace($confirmation)) { $confirmation = 'Y' }

      if ($confirmation.Trim().StartsWith('Y', [System.StringComparison]::OrdinalIgnoreCase)) {
        try {
          if (Test-Path -LiteralPath $path) {
            Write-Info ("Removing malicious script {0}" -f $path)
            Remove-Item -LiteralPath $path -Force -ErrorAction Stop
            $removed += $path
          } else {
            Write-Warn ("Flagged path not found during removal: {0}" -f $path)
          }
        } catch {
          Write-Warn ("Failed to remove {0}: {1}" -f $path, $_.Exception.Message)
        }
      } else {
        $declined += $path
        Write-Info ("User declined removal of {0}" -f $path)
      }
    }

    # Handle network connection removals
    foreach ($item in $flaggedNetworkArray) {
      $path = $item.ExecutablePath
      $reason = $item.Reason
      $confirmation = Read-Host ("Remove suspicious listener? (Y/N, default Y): `"$path`" - $reason")
      if ([string]::IsNullOrWhiteSpace($confirmation)) { $confirmation = 'Y' }

      if ($confirmation.Trim().StartsWith('Y', [System.StringComparison]::OrdinalIgnoreCase)) {
        try {
          if (Test-Path -LiteralPath $path) {
            Write-Info ("Removing suspicious network listener executable {0}" -f $path)
            $processes = Get-Process | Where-Object { $_.Path -eq $path } -ErrorAction SilentlyContinue
            foreach ($proc in $processes) {
              try {
                Write-Info ("Stopping process {0} (PID: {1})" -f $proc.Name, $proc.Id)
                Stop-Process -Id $proc.Id -Force -ErrorAction Stop
              } catch {
                Write-Warn ("Failed to stop process {0}: {1}" -f $proc.Id, $_.Exception.Message)
              }
            }
            Remove-Item -LiteralPath $path -Force -ErrorAction Stop
            $removedNetwork += $path
          } else {
            Write-Warn ("Flagged path not found during removal: {0}" -f $path)
          }
        } catch {
          Write-Warn ("Failed to remove {0}: {1}" -f $path, $_.Exception.Message)
        }
      } else {
        $declinedNetwork += $path
        Write-Info ("User declined removal of {0}" -f $path)
      }
    }

    # Handle outbound connection removals
    foreach ($item in $flaggedOutboundArray) {
      $path = $item.ExecutablePath
      $reason = $item.Reason
      $confirmation = Read-Host ("Remove suspicious outbound connection? (Y/N, default Y): `"$path`" - $reason")
      if ([string]::IsNullOrWhiteSpace($confirmation)) { $confirmation = 'Y' }

      if ($confirmation.Trim().StartsWith('Y', [System.StringComparison]::OrdinalIgnoreCase)) {
        try {
          if (Test-Path -LiteralPath $path) {
            Write-Info ("Removing suspicious outbound connection executable {0}" -f $path)
            $processes = Get-Process | Where-Object { $_.Path -eq $path } -ErrorAction SilentlyContinue
            foreach ($proc in $processes) {
              try {
                Write-Info ("Stopping process {0} (PID: {1})" -f $proc.Name, $proc.Id)
                Stop-Process -Id $proc.Id -Force -ErrorAction Stop
              } catch {
                Write-Warn ("Failed to stop process {0}: {1}" -f $proc.Id, $_.Exception.Message)
              }
            }
            Remove-Item -LiteralPath $path -Force -ErrorAction Stop
            $removedOutbound += $path
          } else {
            Write-Warn ("Flagged path not found during removal: {0}" -f $path)
          }
        } catch {
          Write-Warn ("Failed to remove {0}: {1}" -f $path, $_.Exception.Message)
        }
      } else {
        $declinedOutbound += $path
        Write-Info ("User declined removal of {0}" -f $path)
      }
    }

    # Handle registry removals
    foreach ($item in $flaggedRegistryArray) {
      $regPath = $item.RegistryPath
      $valueName = $item.ValueName
      $reason = $item.Reason
      $confirmation = Read-Host ("Remove registry run key? (Y/N, default Y): `"$regPath\$valueName`" - $reason")
      if ([string]::IsNullOrWhiteSpace($confirmation)) { $confirmation = 'Y' }

      if ($confirmation.Trim().StartsWith('Y', [System.StringComparison]::OrdinalIgnoreCase)) {
        try {
          if (Test-Path -LiteralPath $regPath) {
            Write-Info ("Removing registry value {0}\{1}" -f $regPath, $valueName)
            Remove-ItemProperty -LiteralPath $regPath -Name $valueName -Force -ErrorAction Stop
            $removedRegistry += "$regPath\$valueName"
          } else {
            Write-Warn ("Registry path not found: {0}" -f $regPath)
          }
        } catch {
          Write-Warn ("Failed to remove registry value {0}\{1}: {2}" -f $regPath, $valueName, $_.Exception.Message)
        }
      } else {
        $declinedRegistry += "$regPath\$valueName"
        Write-Info ("User declined removal of {0}\{1}" -f $regPath, $valueName)
      }
    }

    # Handle startup item removals
    foreach ($item in $flaggedStartupArray) {
      $filePath = $item.FilePath
      $reason = $item.Reason
      $confirmation = Read-Host ("Remove startup item? (Y/N, default Y): `"$filePath`" - $reason")
      if ([string]::IsNullOrWhiteSpace($confirmation)) { $confirmation = 'Y' }

      if ($confirmation.Trim().StartsWith('Y', [System.StringComparison]::OrdinalIgnoreCase)) {
        try {
          if (Test-Path -LiteralPath $filePath) {
            Write-Info ("Removing startup item {0}" -f $filePath)
            Remove-Item -LiteralPath $filePath -Force -ErrorAction Stop
            $removedStartup += $filePath
          } else {
            Write-Warn ("Startup item not found: {0}" -f $filePath)
          }
        } catch {
          Write-Warn ("Failed to remove {0}: {1}" -f $filePath, $_.Exception.Message)
        }
      } else {
        $declinedStartup += $filePath
        Write-Info ("User declined removal of {0}" -f $filePath)
      }
    }

    # Handle scheduled task removals
    foreach ($item in $flaggedTasksArray) {
      $taskName = $item.TaskName
      $taskPath = $item.TaskPath
      $reason = $item.Reason
      $confirmation = Read-Host ("Remove scheduled task? (Y/N, default Y): `"$taskPath$taskName`" - $reason")
      if ([string]::IsNullOrWhiteSpace($confirmation)) { $confirmation = 'Y' }

      if ($confirmation.Trim().StartsWith('Y', [System.StringComparison]::OrdinalIgnoreCase)) {
        try {
          Write-Info ("Removing scheduled task {0}{1}" -f $taskPath, $taskName)
          Unregister-ScheduledTask -TaskName $taskName -TaskPath $taskPath -Confirm:$false -ErrorAction Stop
          $removedTasks += "$taskPath$taskName"
        } catch {
          Write-Warn ("Failed to remove task {0}{1}: {2}" -f $taskPath, $taskName, $_.Exception.Message)
        }
      } else {
        $declinedTasks += "$taskPath$taskName"
        Write-Info ("User declined removal of {0}{1}" -f $taskPath, $taskName)
      }
    }

    # Handle WMI persistence removals
    foreach ($item in $flaggedWmiArray) {
      $name = $item.Name
      $objectType = $item.ObjectType
      $reason = $item.Reason
      $confirmation = Read-Host ("Remove WMI persistence? (Y/N, default Y): `"$name`" ($objectType) - $reason")
      if ([string]::IsNullOrWhiteSpace($confirmation)) { $confirmation = 'Y' }

      if ($confirmation.Trim().StartsWith('Y', [System.StringComparison]::OrdinalIgnoreCase)) {
        try {
          Write-Info ("Removing WMI {0} `"{1}`"" -f $objectType, $name)

          if ($objectType -eq 'EventFilter') {
            $wmiObject = Get-WmiObject -Namespace 'root\subscription' -Class '__EventFilter' -Filter "Name='$name'" -ErrorAction Stop
            $wmiObject.Delete()
          } elseif ($objectType -eq 'EventConsumer') {
            # Try different consumer types
            $consumerClasses = @('CommandLineEventConsumer', 'ActiveScriptEventConsumer', 'LogFileEventConsumer', 'NTEventLogEventConsumer', 'SMTPEventConsumer')
            foreach ($class in $consumerClasses) {
              $wmiObject = Get-WmiObject -Namespace 'root\subscription' -Class $class -Filter "Name='$name'" -ErrorAction SilentlyContinue
              if ($wmiObject) {
                $wmiObject.Delete()
                break
              }
            }
          } elseif ($objectType -eq 'Binding') {
            $wmiObject = Get-WmiObject -Namespace 'root\subscription' -Class '__FilterToConsumerBinding' -ErrorAction Stop |
              Where-Object { $_.Filter -match "Name=`"$name`"" -or $_.Consumer -match "Name=`"$name`"" }
            if ($wmiObject) {
              $wmiObject.Delete()
            }
          }

          $removedWmi += "$objectType : $name"
        } catch {
          Write-Warn ("Failed to remove WMI {0} {1}: {2}" -f $objectType, $name, $_.Exception.Message)
        }
      } else {
        $declinedWmi += "$objectType : $name"
        Write-Info ("User declined removal of {0} {1}" -f $objectType, $name)
      }
    }
  }

  return [pscustomobject]@{
    InventoryCount     = $inventoryCount
    NetworkCount       = $networkCount
    OutboundCount      = $outboundCount
    RegistryCount      = $registryCount
    StartupCount       = $startupCount
    TasksCount         = $tasksCount
    WmiCount           = $wmiCount
    Flagged            = @($flaggedArray)
    FlaggedNetwork     = @($flaggedNetworkArray)
    FlaggedOutbound    = @($flaggedOutboundArray)
    FlaggedRegistry    = @($flaggedRegistryArray)
    FlaggedStartup     = @($flaggedStartupArray)
    FlaggedTasks       = @($flaggedTasksArray)
    FlaggedWmi         = @($flaggedWmiArray)
    Removed            = @($removed)
    RemovedNetwork     = @($removedNetwork)
    RemovedOutbound    = @($removedOutbound)
    RemovedRegistry    = @($removedRegistry)
    RemovedStartup     = @($removedStartup)
    RemovedTasks       = @($removedTasks)
    RemovedWmi         = @($removedWmi)
    Declined           = @($declined)
    DeclinedNetwork    = @($declinedNetwork)
    DeclinedOutbound   = @($declinedOutbound)
    DeclinedRegistry   = @($declinedRegistry)
    DeclinedStartup    = @($declinedStartup)
    DeclinedTasks      = @($declinedTasks)
    DeclinedWmi        = @($declinedWmi)
  }
}

function Get-ResultSummary {
  param($Result)

  if (-not $Result) { return 'Malware persistence scan completed.' }

  # Extract all arrays
  $flaggedArray = @($Result.Flagged)
  $removedArray = @($Result.Removed)
  $declinedArray = @($Result.Declined)
  $flaggedNetworkArray = @($Result.FlaggedNetwork)
  $removedNetworkArray = @($Result.RemovedNetwork)
  $declinedNetworkArray = @($Result.DeclinedNetwork)
  $flaggedOutboundArray = @($Result.FlaggedOutbound)
  $removedOutboundArray = @($Result.RemovedOutbound)
  $declinedOutboundArray = @($Result.DeclinedOutbound)
  $flaggedRegistryArray = @($Result.FlaggedRegistry)
  $removedRegistryArray = @($Result.RemovedRegistry)
  $declinedRegistryArray = @($Result.DeclinedRegistry)
  $flaggedStartupArray = @($Result.FlaggedStartup)
  $removedStartupArray = @($Result.RemovedStartup)
  $declinedStartupArray = @($Result.DeclinedStartup)
  $flaggedTasksArray = @($Result.FlaggedTasks)
  $removedTasksArray = @($Result.RemovedTasks)
  $declinedTasksArray = @($Result.DeclinedTasks)
  $flaggedWmiArray = @($Result.FlaggedWmi)
  $removedWmiArray = @($Result.RemovedWmi)
  $declinedWmiArray = @($Result.DeclinedWmi)

  # Count everything
  $flaggedCount = if ($flaggedArray) { $flaggedArray.Count } else { 0 }
  $removedCount = if ($removedArray) { $removedArray.Count } else { 0 }
  $declinedCount = if ($declinedArray) { $declinedArray.Count } else { 0 }
  $flaggedNetworkCount = if ($flaggedNetworkArray) { $flaggedNetworkArray.Count } else { 0 }
  $removedNetworkCount = if ($removedNetworkArray) { $removedNetworkArray.Count } else { 0 }
  $declinedNetworkCount = if ($declinedNetworkArray) { $declinedNetworkArray.Count } else { 0 }
  $flaggedOutboundCount = if ($flaggedOutboundArray) { $flaggedOutboundArray.Count } else { 0 }
  $removedOutboundCount = if ($removedOutboundArray) { $removedOutboundArray.Count } else { 0 }
  $declinedOutboundCount = if ($declinedOutboundArray) { $declinedOutboundArray.Count } else { 0 }
  $flaggedRegistryCount = if ($flaggedRegistryArray) { $flaggedRegistryArray.Count } else { 0 }
  $removedRegistryCount = if ($removedRegistryArray) { $removedRegistryArray.Count } else { 0 }
  $declinedRegistryCount = if ($declinedRegistryArray) { $declinedRegistryArray.Count } else { 0 }
  $flaggedStartupCount = if ($flaggedStartupArray) { $flaggedStartupArray.Count } else { 0 }
  $removedStartupCount = if ($removedStartupArray) { $removedStartupArray.Count } else { 0 }
  $declinedStartupCount = if ($declinedStartupArray) { $declinedStartupArray.Count } else { 0 }
  $flaggedTasksCount = if ($flaggedTasksArray) { $flaggedTasksArray.Count } else { 0 }
  $removedTasksCount = if ($removedTasksArray) { $removedTasksArray.Count } else { 0 }
  $declinedTasksCount = if ($declinedTasksArray) { $declinedTasksArray.Count } else { 0 }
  $flaggedWmiCount = if ($flaggedWmiArray) { $flaggedWmiArray.Count } else { 0 }
  $removedWmiCount = if ($removedWmiArray) { $removedWmiArray.Count } else { 0 }
  $declinedWmiCount = if ($declinedWmiArray) { $declinedWmiArray.Count } else { 0 }

  # Calculate totals
  $totalFlagged = $flaggedCount + $flaggedNetworkCount + $flaggedOutboundCount + $flaggedRegistryCount +
                  $flaggedStartupCount + $flaggedTasksCount + $flaggedWmiCount
  $totalRemoved = $removedCount + $removedNetworkCount + $removedOutboundCount + $removedRegistryCount +
                  $removedStartupCount + $removedTasksCount + $removedWmiCount
  $totalDeclined = $declinedCount + $declinedNetworkCount + $declinedOutboundCount + $declinedRegistryCount +
                   $declinedStartupCount + $declinedTasksCount + $declinedWmiCount

  # Build summary message
  $parts = @()

  # Flagged items summary
  $flaggedDetails = @()
  if ($flaggedCount -gt 0) { $flaggedDetails += "$flaggedCount script(s)" }
  if ($flaggedNetworkCount -gt 0) { $flaggedDetails += "$flaggedNetworkCount listener(s)" }
  if ($flaggedOutboundCount -gt 0) { $flaggedDetails += "$flaggedOutboundCount outbound connection(s)" }
  if ($flaggedRegistryCount -gt 0) { $flaggedDetails += "$flaggedRegistryCount registry key(s)" }
  if ($flaggedStartupCount -gt 0) { $flaggedDetails += "$flaggedStartupCount startup item(s)" }
  if ($flaggedTasksCount -gt 0) { $flaggedDetails += "$flaggedTasksCount task(s)" }
  if ($flaggedWmiCount -gt 0) { $flaggedDetails += "$flaggedWmiCount WMI item(s)" }

  if ($flaggedDetails.Count -gt 0) {
    $parts += "Flagged: " + ($flaggedDetails -join ', ') + "."
  } else {
    $parts += "No suspicious items flagged."
  }

  # Removed items summary
  if ($totalRemoved -gt 0) {
    $removedDetails = @()
    if ($removedCount -gt 0) { $removedDetails += "$removedCount script(s)" }
    if ($removedNetworkCount -gt 0) { $removedDetails += "$removedNetworkCount listener(s)" }
    if ($removedOutboundCount -gt 0) { $removedDetails += "$removedOutboundCount outbound connection(s)" }
    if ($removedRegistryCount -gt 0) { $removedDetails += "$removedRegistryCount registry key(s)" }
    if ($removedStartupCount -gt 0) { $removedDetails += "$removedStartupCount startup item(s)" }
    if ($removedTasksCount -gt 0) { $removedDetails += "$removedTasksCount task(s)" }
    if ($removedWmiCount -gt 0) { $removedDetails += "$removedWmiCount WMI item(s)" }
    $parts += "Removed: " + ($removedDetails -join ', ') + "."
  } else {
    $parts += "No removals performed."
  }

  # Declined items summary
  if ($totalDeclined -gt 0) {
    $declinedDetails = @()
    if ($declinedCount -gt 0) { $declinedDetails += "$declinedCount script(s)" }
    if ($declinedNetworkCount -gt 0) { $declinedDetails += "$declinedNetworkCount listener(s)" }
    if ($declinedOutboundCount -gt 0) { $declinedDetails += "$declinedOutboundCount outbound connection(s)" }
    if ($declinedRegistryCount -gt 0) { $declinedDetails += "$declinedRegistryCount registry key(s)" }
    if ($declinedStartupCount -gt 0) { $declinedDetails += "$declinedStartupCount startup item(s)" }
    if ($declinedTasksCount -gt 0) { $declinedDetails += "$declinedTasksCount task(s)" }
    if ($declinedWmiCount -gt 0) { $declinedDetails += "$declinedWmiCount WMI item(s)" }
    $parts += "Declined: " + ($declinedDetails -join ', ') + "."
  }

  return ($parts -join ' ')
}

function Invoke-Verify {
  param($Context)

  try {
    $result = Invoke-MalwareAssessment
  } catch {
    Write-Err ("MalwarePersistence verification failed: {0}" -f $_.Exception.Message)
    return (New-ModuleResult -Name $script:ModuleName -Status 'Failed' -Message ('Verification error: ' + $_.Exception.Message))
  }

  $message = Get-ResultSummary -Result $result
  return (New-ModuleResult -Name $script:ModuleName -Status 'Succeeded' -Message $message)
}

function Invoke-Apply {
  param($Context)

  try {
    $result = Invoke-MalwareAssessment -Remove
  } catch {
    Write-Err ("MalwarePersistence apply failed: {0}" -f $_.Exception.Message)
    return (New-ModuleResult -Name $script:ModuleName -Status 'Failed' -Message ('Apply error: ' + $_.Exception.Message))
  }

  $message = Get-ResultSummary -Result $result
  return (New-ModuleResult -Name $script:ModuleName -Status 'Succeeded' -Message $message)
}

Export-ModuleMember -Function Test-Ready,Invoke-Verify,Invoke-Apply
