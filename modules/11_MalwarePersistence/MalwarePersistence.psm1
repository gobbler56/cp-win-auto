Set-StrictMode -Version Latest

if (-not (Get-Command New-ModuleResult -EA SilentlyContinue)) {
  Import-Module -Force -DisableNameChecking (Join-Path $PSScriptRoot '../../core/Contracts.psm1')
}
if (-not (Get-Command Write-Info -EA SilentlyContinue)) {
  Import-Module -Force -DisableNameChecking (Join-Path $PSScriptRoot '../../core/Utils.psm1')
}

$script:ModuleName       = 'MalwarePersistence'
$script:ApiUrl           = 'https://openrouter.ai/api/v1/chat/completions'
$script:ApiKeyEnvVar     = 'OPENROUTER_API_KEY'
$script:ScanDirectories  = @('C:\\Users', 'C:\\ProgramData')
$script:ScriptExtensions = @('.ps1','.psm1','.bat','.cmd','.vbs','.js','.jse','.hta','.py','.zip')

function Get-OpenRouterApiKey {
  $key = [System.Environment]::GetEnvironmentVariable($script:ApiKeyEnvVar)
  if (-not $key) { return '' }
  return $key
}

function Test-Ready {
  param($Context)

  if (-not (Get-OpenRouterApiKey)) {
    Write-Warn "OpenRouter API key is missing (set `$env:$($script:ApiKeyEnvVar)); cannot classify suspicious scripts."
    return $false
  }

  return $true
}

function Get-ScriptInventory {
  $collected = New-Object 'System.Collections.Generic.List[string]'

  foreach ($root in $script:ScanDirectories) {
    if ([string]::IsNullOrWhiteSpace($root)) { continue }
    if (-not (Test-Path -LiteralPath $root)) { continue }

    try {
      $items = Get-ChildItem -LiteralPath $root -File -Recurse -ErrorAction Stop
    } catch {
      Write-Warn ("Failed to enumerate {0}: {1}" -f $root, $_.Exception.Message)
      continue
    }

    foreach ($item in $items) {
      try {
        $ext = [System.IO.Path]::GetExtension($item.Name)
      } catch {
        $ext = ''
      }

      if (-not $ext) { continue }
      $extLower = $ext.ToLowerInvariant()
      if ($script:ScriptExtensions -contains $extLower) {
        if (-not $collected.Contains($item.FullName)) {
          $collected.Add($item.FullName) | Out-Null
        }
      }
    }
  }

  $unique = $collected | Sort-Object -Unique
  return @($unique)
}

function Build-AiRequest {
  param([string[]]$Inventory)

  $systemPrompt = @"
You are a Windows incident response assistant for CyberPatriot scoring.
Return ONLY a raw JSON array (no code fences) of absolute filesystem paths for script files that are malicious or suspicious persistence mechanisms which should be removed.
Only mark files that are clearly malicious, suspicious persistence, or not required for legitimate software operation.
If no files require removal, respond with [].
"@

  $inventoryArray = @($Inventory)
  $inventoryBlock = ($inventoryArray -join [Environment]::NewLine)
  $userPrompt = @"
You are reviewing script files collected from persistence-prone directories on a Windows system.

SCANNED FILES ($($inventoryArray.Count) entries):
$inventoryBlock

Identify the files that are malicious or suspicious and should be removed. Respond ONLY with a JSON array of paths.
"@

  $body = @{
    model       = 'openai/gpt-5'
    temperature = 0
    max_tokens  = 4000
    messages    = @(
      @{ role = 'system'; content = $systemPrompt },
      @{ role = 'user'; content = $userPrompt }
    )
  }

  return $body | ConvertTo-Json -Depth 6
}

function Invoke-Classification {
  param([string[]]$Inventory)

  $inventoryArray = @($Inventory)

  if (-not $inventoryArray -or $inventoryArray.Count -eq 0) {
    return @()
  }

  $bodyJson = Build-AiRequest -Inventory $inventoryArray

  $apiKey = Get-OpenRouterApiKey
  if (-not $apiKey) {
    throw 'OpenRouter API key was not available when classification was attempted.'
  }

  $headers = @{
    'Authorization' = "Bearer $apiKey"
    'Content-Type'  = 'application/json'
  }

  try {
    $response = Invoke-RestMethod -Uri $script:ApiUrl -Method Post -Headers $headers -Body $bodyJson -ErrorAction Stop
  } catch {
    throw ("OpenRouter API call failed: {0}" -f $_.Exception.Message)
  }

  $content = $response.choices[0].message.content
  if (-not $content) {
    throw 'OpenRouter returned an empty response.'
  }

  $content = $content -replace '^```json\s*', '' -replace '\s*```$',''

  try {
    $parsed = $content | ConvertFrom-Json
  } catch {
    throw ("Failed to parse OpenRouter response: {0}" -f $_.Exception.Message)
  }

  if ($parsed -isnot [System.Collections.IEnumerable]) {
    throw 'OpenRouter response was not an array.'
  }

  $paths = @()
  foreach ($item in $parsed) {
    if ($item -is [string]) {
      $value = $item.Trim()
      if ($value) { $paths += $value }
    }
  }

  return @($paths | Sort-Object -Unique)
}

function Get-NetworkListenerInventory {
  $connections = @()

  try {
    $listeners = Get-NetTCPConnection -State Listen -ErrorAction Stop |
      Sort-Object LocalPort |
      Select-Object LocalPort, OwningProcess,
        @{Name='ProcessName';Expression={
            (Get-Process -Id $_.OwningProcess -ErrorAction SilentlyContinue).ProcessName
        }},
        @{Name='ExecutablePath';Expression={
            (Get-CimInstance Win32_Process -Filter "ProcessId=$($_.OwningProcess)" -ErrorAction SilentlyContinue).ExecutablePath
        }}

    foreach ($listener in $listeners) {
      if ($listener.ExecutablePath) {
        $connections += [pscustomobject]@{
          LocalPort      = $listener.LocalPort
          ProcessId      = $listener.OwningProcess
          ProcessName    = $listener.ProcessName
          ExecutablePath = $listener.ExecutablePath
        }
      }
    }
  } catch {
    Write-Warn ("Failed to enumerate network listeners: {0}" -f $_.Exception.Message)
  }

  return @($connections)
}

function Build-NetworkAiRequest {
  param([array]$Connections)

  $systemPrompt = @"
You are a Windows incident response assistant for CyberPatriot scoring.
Return ONLY a raw JSON array (no code fences) of objects identifying suspicious listening network connections that may be backdoors or malware.
Each object should have: {"ExecutablePath": "path", "Reason": "explanation"}.

CRITICAL: In CyberPatriot, ANY non-default Windows listening process is suspicious except CCSclient.
- Flag ANY executable in System32 that is not a standard Windows service (backdoors like netcat are often renamed to innocent names like "exportfile.exe", "update.exe", "svchost32.exe", etc.)
- Flag ANY listening processes from user directories, temp folders, or unusual locations
- Flag processes with generic/suspicious names even if they don't match known malware signatures
- Do NOT rely on filename alone - attackers rename tools to evade detection
- The ONLY exception is CCSclient - do not flag it
- When in doubt, FLAG IT for manual review - false positives are acceptable in CyberPatriot context

Standard Windows services that should NOT be flagged include: svchost.exe, System, lsass.exe, spoolsv.exe, services.exe, wininit.exe, csrss.exe, smss.exe, dwm.exe, taskhost.exe, taskhostw.exe, SearchIndexer.exe, explorer.exe, RuntimeBroker.exe
Any executable not in this list or CCSclient should be considered suspicious.

If no connections are suspicious, respond with [].
"@

  $connectionsBlock = ($Connections | ForEach-Object {
    "Port: $($_.LocalPort) | PID: $($_.ProcessId) | Process: $($_.ProcessName) | Path: $($_.ExecutablePath)"
  }) -join [Environment]::NewLine

  $userPrompt = @"
You are reviewing listening network connections on a Windows system for potential backdoors or malware.

LISTENING CONNECTIONS ($($Connections.Count) entries):
$connectionsBlock

Identify suspicious connections that may be backdoors or malware. Respond ONLY with a JSON array.
"@

  $body = @{
    model       = 'openai/gpt-5'
    temperature = 0
    max_tokens  = 4000
    messages    = @(
      @{ role = 'system'; content = $systemPrompt },
      @{ role = 'user'; content = $userPrompt }
    )
  }

  return $body | ConvertTo-Json -Depth 6
}

function Invoke-NetworkListenerClassification {
  param([array]$Connections)

  if (-not $Connections -or $Connections.Count -eq 0) {
    return @()
  }

  $bodyJson = Build-NetworkAiRequest -Connections $Connections

  $apiKey = Get-OpenRouterApiKey
  if (-not $apiKey) {
    throw 'OpenRouter API key was not available when classification was attempted.'
  }

  $headers = @{
    'Authorization' = "Bearer $apiKey"
    'Content-Type'  = 'application/json'
  }

  try {
    $response = Invoke-RestMethod -Uri $script:ApiUrl -Method Post -Headers $headers -Body $bodyJson -ErrorAction Stop
  } catch {
    throw ("OpenRouter API call failed: {0}" -f $_.Exception.Message)
  }

  $content = $response.choices[0].message.content
  if (-not $content) {
    throw 'OpenRouter returned an empty response.'
  }

  $content = $content -replace '^```json\s*', '' -replace '\s*```$',''

  try {
    $parsed = $content | ConvertFrom-Json
  } catch {
    throw ("Failed to parse OpenRouter response: {0}" -f $_.Exception.Message)
  }

  if ($parsed -isnot [System.Collections.IEnumerable]) {
    throw 'OpenRouter response was not an array.'
  }

  return @($parsed)
}

function Invoke-MalwareAssessment {
  param([switch]$Remove)

  Write-Info 'Enumerating potential persistence scripts'
  $inventory = Get-ScriptInventory
  $inventoryArray = @($inventory)
  $inventoryCount = $inventoryArray.Count
  Write-Info ("Collected {0} script file(s)" -f $inventoryCount)

  Write-Info 'Enumerating listening network connections'
  $networkConnections = Get-NetworkListenerInventory
  $networkCount = $networkConnections.Count
  Write-Info ("Collected {0} listening connection(s)" -f $networkCount)

  if ($inventoryCount -eq 0 -and $networkCount -eq 0) {
    return [pscustomobject]@{
      InventoryCount     = 0
      NetworkCount       = 0
      Flagged            = @()
      FlaggedNetwork     = @()
      Removed            = @()
      RemovedNetwork     = @()
      Declined           = @()
      DeclinedNetwork    = @()
    }
  }

  # Process script files
  $flaggedArray = @()
  if ($inventoryCount -gt 0) {
    Write-Info 'Requesting AI analysis for scripts from OpenRouter'
    $flagged = Invoke-Classification -Inventory $inventoryArray
    $flaggedArray = @($flagged)
  }

  # Process network connections
  $flaggedNetworkArray = @()
  if ($networkCount -gt 0) {
    Write-Info 'Requesting AI analysis for network connections from OpenRouter'
    $flaggedNetwork = Invoke-NetworkListenerClassification -Connections $networkConnections
    $flaggedNetworkArray = @($flaggedNetwork)
  }

  if ((-not $flaggedArray -or $flaggedArray.Count -eq 0) -and
      (-not $flaggedNetworkArray -or $flaggedNetworkArray.Count -eq 0)) {
    Write-Info 'AI did not flag any items for removal'
    return [pscustomobject]@{
      InventoryCount     = $inventoryCount
      NetworkCount       = $networkCount
      Flagged            = @()
      FlaggedNetwork     = @()
      Removed            = @()
      RemovedNetwork     = @()
      Declined           = @()
      DeclinedNetwork    = @()
    }
  }

  # Display flagged scripts
  if ($flaggedArray -and $flaggedArray.Count -gt 0) {
    Write-Info 'AI flagged the following script paths for review:'
    foreach ($path in $flaggedArray) {
      Write-Host ("  - {0}" -f $path)
    }
  }

  # Display flagged network connections
  if ($flaggedNetworkArray -and $flaggedNetworkArray.Count -gt 0) {
    Write-Info 'AI flagged the following network connections as suspicious:'
    foreach ($item in $flaggedNetworkArray) {
      Write-Host ("  - {0} (Reason: {1})" -f $item.ExecutablePath, $item.Reason)
    }
  }

  $removed = @()
  $declined = @()
  $removedNetwork = @()
  $declinedNetwork = @()

  if ($Remove) {
    # Handle script removals
    foreach ($path in $flaggedArray) {
      $confirmation = Read-Host ("Remove flagged script path? (Y/N, default Y): `"$path`"")
      if ([string]::IsNullOrWhiteSpace($confirmation)) { $confirmation = 'Y' }

      if ($confirmation.Trim().StartsWith('Y', [System.StringComparison]::OrdinalIgnoreCase)) {
        try {
          if (Test-Path -LiteralPath $path) {
            Write-Info ("Removing malicious script {0}" -f $path)
            Remove-Item -LiteralPath $path -Force -ErrorAction Stop
            $removed += $path
          } else {
            Write-Warn ("Flagged path not found during removal: {0}" -f $path)
          }
        } catch {
          Write-Warn ("Failed to remove {0}: {1}" -f $path, $_.Exception.Message)
        }
      } else {
        $declined += $path
        Write-Info ("User declined removal of {0}" -f $path)
      }
    }

    # Handle network connection removals
    foreach ($item in $flaggedNetworkArray) {
      $path = $item.ExecutablePath
      $reason = $item.Reason
      $confirmation = Read-Host ("Remove suspicious listener? (Y/N, default Y): `"$path`" - $reason")
      if ([string]::IsNullOrWhiteSpace($confirmation)) { $confirmation = 'Y' }

      if ($confirmation.Trim().StartsWith('Y', [System.StringComparison]::OrdinalIgnoreCase)) {
        try {
          if (Test-Path -LiteralPath $path) {
            Write-Info ("Removing suspicious network listener executable {0}" -f $path)
            # First, try to stop any running processes
            $processes = Get-Process | Where-Object { $_.Path -eq $path } -ErrorAction SilentlyContinue
            foreach ($proc in $processes) {
              try {
                Write-Info ("Stopping process {0} (PID: {1})" -f $proc.Name, $proc.Id)
                Stop-Process -Id $proc.Id -Force -ErrorAction Stop
              } catch {
                Write-Warn ("Failed to stop process {0}: {1}" -f $proc.Id, $_.Exception.Message)
              }
            }
            # Remove the executable
            Remove-Item -LiteralPath $path -Force -ErrorAction Stop
            $removedNetwork += $path
          } else {
            Write-Warn ("Flagged path not found during removal: {0}" -f $path)
          }
        } catch {
          Write-Warn ("Failed to remove {0}: {1}" -f $path, $_.Exception.Message)
        }
      } else {
        $declinedNetwork += $path
        Write-Info ("User declined removal of {0}" -f $path)
      }
    }
  }

  return [pscustomobject]@{
    InventoryCount     = $inventoryCount
    NetworkCount       = $networkCount
    Flagged            = @($flaggedArray)
    FlaggedNetwork     = @($flaggedNetworkArray)
    Removed            = @($removed)
    RemovedNetwork     = @($removedNetwork)
    Declined           = @($declined)
    DeclinedNetwork    = @($declinedNetwork)
  }
}

function Get-ResultSummary {
  param($Result)

  if (-not $Result) { return 'Malware persistence scan completed.' }

  $flaggedArray = @($Result.Flagged)
  $removedArray = @($Result.Removed)
  $declinedArray = @($Result.Declined)
  $flaggedNetworkArray = @($Result.FlaggedNetwork)
  $removedNetworkArray = @($Result.RemovedNetwork)
  $declinedNetworkArray = @($Result.DeclinedNetwork)

  $flaggedCount = if ($flaggedArray) { $flaggedArray.Count } else { 0 }
  $removedCount = if ($removedArray) { $removedArray.Count } else { 0 }
  $declinedCount = if ($declinedArray) { $declinedArray.Count } else { 0 }
  $flaggedNetworkCount = if ($flaggedNetworkArray) { $flaggedNetworkArray.Count } else { 0 }
  $removedNetworkCount = if ($removedNetworkArray) { $removedNetworkArray.Count } else { 0 }
  $declinedNetworkCount = if ($declinedNetworkArray) { $declinedNetworkArray.Count } else { 0 }

  $parts = @()
  $parts += ("Flagged {0} script file(s) and {1} suspicious network listener(s)." -f $flaggedCount, $flaggedNetworkCount)

  $totalRemoved = $removedCount + $removedNetworkCount
  if ($totalRemoved -gt 0) {
    $parts += ("Removed {0} script(s) and {1} listener(s)." -f $removedCount, $removedNetworkCount)
  } else {
    $parts += 'No removals performed.'
  }

  $totalDeclined = $declinedCount + $declinedNetworkCount
  if ($totalDeclined -gt 0) {
    $parts += ("User declined {0} script(s) and {1} listener(s)." -f $declinedCount, $declinedNetworkCount)
  }

  return ($parts -join ' ')
}

function Invoke-Verify {
  param($Context)

  try {
    $result = Invoke-MalwareAssessment
  } catch {
    Write-Err ("MalwarePersistence verification failed: {0}" -f $_.Exception.Message)
    return (New-ModuleResult -Name $script:ModuleName -Status 'Failed' -Message ('Verification error: ' + $_.Exception.Message))
  }

  $message = Get-ResultSummary -Result $result
  return (New-ModuleResult -Name $script:ModuleName -Status 'Succeeded' -Message $message)
}

function Invoke-Apply {
  param($Context)

  try {
    $result = Invoke-MalwareAssessment -Remove
  } catch {
    Write-Err ("MalwarePersistence apply failed: {0}" -f $_.Exception.Message)
    return (New-ModuleResult -Name $script:ModuleName -Status 'Failed' -Message ('Apply error: ' + $_.Exception.Message))
  }

  $message = Get-ResultSummary -Result $result
  return (New-ModuleResult -Name $script:ModuleName -Status 'Succeeded' -Message $message)
}

Export-ModuleMember -Function Test-Ready,Invoke-Verify,Invoke-Apply
