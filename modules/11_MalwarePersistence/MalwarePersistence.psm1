Set-StrictMode -Version Latest

if (-not (Get-Command New-ModuleResult -EA SilentlyContinue)) {
  Import-Module -Force -DisableNameChecking (Join-Path $PSScriptRoot '../../core/Contracts.psm1')
}
if (-not (Get-Command Write-Info -EA SilentlyContinue)) {
  Import-Module -Force -DisableNameChecking (Join-Path $PSScriptRoot '../../core/Utils.psm1')
}

$script:ModuleName       = 'MalwarePersistence'
$script:ApiUrl           = 'https://openrouter.ai/api/v1/chat/completions'
$script:ApiKeyEnvVar     = 'OPENROUTER_API_KEY'
$script:ScanDirectories  = @('C:\\Users', 'C:\\ProgramData')
$script:ScriptExtensions = @('.ps1','.psm1','.bat','.cmd','.vbs','.js','.jse','.hta','.py','.zip')

function Get-OpenRouterApiKey {
  $key = [System.Environment]::GetEnvironmentVariable($script:ApiKeyEnvVar)
  if (-not $key) { return '' }
  return $key
}

function Test-Ready {
  param($Context)

  if (-not (Get-OpenRouterApiKey)) {
    Write-Warn "OpenRouter API key is missing (set `$env:$($script:ApiKeyEnvVar)); cannot classify suspicious scripts."
    return $false
  }

  return $true
}

function Get-ScriptInventory {
  $collected = New-Object 'System.Collections.Generic.List[string]'

  foreach ($root in $script:ScanDirectories) {
    if ([string]::IsNullOrWhiteSpace($root)) { continue }
    if (-not (Test-Path -LiteralPath $root)) { continue }

    try {
      $items = Get-ChildItem -LiteralPath $root -File -Recurse -ErrorAction Stop
    } catch {
      Write-Warn ("Failed to enumerate {0}: {1}" -f $root, $_.Exception.Message)
      continue
    }

    foreach ($item in $items) {
      try {
        $ext = [System.IO.Path]::GetExtension($item.Name)
      } catch {
        $ext = ''
      }

      if (-not $ext) { continue }
      $extLower = $ext.ToLowerInvariant()
      if ($script:ScriptExtensions -contains $extLower) {
        if (-not $collected.Contains($item.FullName)) {
          $collected.Add($item.FullName) | Out-Null
        }
      }
    }
  }

  $unique = $collected | Sort-Object -Unique
  return @($unique)
}

function Build-AiRequest {
  param([string[]]$Inventory)

  $systemPrompt = @"
You are a Windows incident response assistant for CyberPatriot scoring.
Return ONLY a raw JSON array (no code fences) of absolute filesystem paths for script files that are malicious or suspicious persistence mechanisms which should be removed.
Only mark files that are clearly malicious, suspicious persistence, or not required for legitimate software operation.
If no files require removal, respond with [].
"@

  $inventoryArray = @($Inventory)
  $inventoryBlock = ($inventoryArray -join [Environment]::NewLine)
  $userPrompt = @"
You are reviewing script files collected from persistence-prone directories on a Windows system.

SCANNED FILES ($($inventoryArray.Count) entries):
$inventoryBlock

Identify the files that are malicious or suspicious and should be removed. Respond ONLY with a JSON array of paths.
"@

  $body = @{
    model       = 'openai/gpt-5'
    temperature = 0
    max_tokens  = 4000
    messages    = @(
      @{ role = 'system'; content = $systemPrompt },
      @{ role = 'user'; content = $userPrompt }
    )
  }

  return $body | ConvertTo-Json -Depth 6
}

function Invoke-Classification {
  param([string[]]$Inventory)

  $inventoryArray = @($Inventory)

  if (-not $inventoryArray -or $inventoryArray.Count -eq 0) {
    return @()
  }

  $bodyJson = Build-AiRequest -Inventory $inventoryArray

  $apiKey = Get-OpenRouterApiKey
  if (-not $apiKey) {
    throw 'OpenRouter API key was not available when classification was attempted.'
  }

  $headers = @{
    'Authorization' = "Bearer $apiKey"
    'Content-Type'  = 'application/json'
  }

  try {
    $response = Invoke-RestMethod -Uri $script:ApiUrl -Method Post -Headers $headers -Body $bodyJson -ErrorAction Stop
  } catch {
    throw ("OpenRouter API call failed: {0}" -f $_.Exception.Message)
  }

  $content = $response.choices[0].message.content
  if (-not $content) {
    throw 'OpenRouter returned an empty response.'
  }

  $content = $content -replace '^```json\s*', '' -replace '\s*```$',''

  try {
    $parsed = $content | ConvertFrom-Json
  } catch {
    throw ("Failed to parse OpenRouter response: {0}" -f $_.Exception.Message)
  }

  if ($parsed -isnot [System.Collections.IEnumerable]) {
    throw 'OpenRouter response was not an array.'
  }

  $paths = @()
  foreach ($item in $parsed) {
    if ($item -is [string]) {
      $value = $item.Trim()
      if ($value) { $paths += $value }
    }
  }

  return @($paths | Sort-Object -Unique)
}

function Invoke-MalwareAssessment {
  param([switch]$Remove)

  Write-Info 'Enumerating potential persistence scripts'
  $inventory = Get-ScriptInventory
  $inventoryArray = @($inventory)
  $inventoryCount = $inventoryArray.Count
  Write-Info ("Collected {0} script file(s)" -f $inventoryCount)

  if ($inventoryCount -eq 0) {
    return [pscustomobject]@{
      InventoryCount = 0
      Flagged        = @()
      Removed        = @()
      Declined       = @()
    }
  }

  Write-Info 'Requesting AI analysis from OpenRouter'
  $flagged = Invoke-Classification -Inventory $inventoryArray

  $flaggedArray = @($flagged)

  if (-not $flaggedArray -or $flaggedArray.Count -eq 0) {
    Write-Info 'AI did not flag any scripts for removal'
    return [pscustomobject]@{
      InventoryCount = $inventoryCount
      Flagged        = @()
      Removed        = @()
      Declined       = @()
    }
  }

  Write-Info 'AI flagged the following script paths for review:'
  foreach ($path in $flaggedArray) {
    Write-Host ("  - {0}" -f $path)
  }

  $removed = @()
  $declined = @()

  if ($Remove) {
    foreach ($path in $flaggedArray) {
      $confirmation = Read-Host ("Remove flagged script path? (Y/N, default Y): `"$path`"")
      if ([string]::IsNullOrWhiteSpace($confirmation)) { $confirmation = 'Y' }

      if ($confirmation.Trim().StartsWith('Y', [System.StringComparison]::OrdinalIgnoreCase)) {
        try {
          if (Test-Path -LiteralPath $path) {
            Write-Info ("Removing malicious script {0}" -f $path)
            Remove-Item -LiteralPath $path -Force -ErrorAction Stop
            $removed += $path
          } else {
            Write-Warn ("Flagged path not found during removal: {0}" -f $path)
          }
        } catch {
          Write-Warn ("Failed to remove {0}: {1}" -f $path, $_.Exception.Message)
        }
      } else {
        $declined += $path
        Write-Info ("User declined removal of {0}" -f $path)
      }
    }
  }

  return [pscustomobject]@{
    InventoryCount = $inventoryCount
    Flagged        = @($flaggedArray)
    Removed        = @($removed)
    Declined       = @($declined)
  }
}

function Get-ResultSummary {
  param($Result)

  if (-not $Result) { return 'Malware persistence scan completed.' }

  $flaggedArray = @($Result.Flagged)
  $removedArray = @($Result.Removed)
  $declinedArray = @($Result.Declined)

  $flaggedCount = if ($flaggedArray) { $flaggedArray.Count } else { 0 }
  $removedCount = if ($removedArray) { $removedArray.Count } else { 0 }
  $declinedCount = if ($declinedArray) { $declinedArray.Count } else { 0 }

  $parts = @()
  $parts += ("Flagged {0} script file(s)." -f $flaggedCount)
  if ($removedCount -gt 0) {
    $parts += ("Removed {0}." -f $removedCount)
  } else {
    $parts += 'No removals performed.'
  }
  if ($declinedCount -gt 0) {
    $parts += ("User declined {0}." -f $declinedCount)
  }

  return ($parts -join ' ')
}

function Invoke-Verify {
  param($Context)

  try {
    $result = Invoke-MalwareAssessment
  } catch {
    Write-Err ("MalwarePersistence verification failed: {0}" -f $_.Exception.Message)
    return (New-ModuleResult -Name $script:ModuleName -Status 'Failed' -Message ('Verification error: ' + $_.Exception.Message))
  }

  $message = Get-ResultSummary -Result $result
  return (New-ModuleResult -Name $script:ModuleName -Status 'Succeeded' -Message $message)
}

function Invoke-Apply {
  param($Context)

  try {
    $result = Invoke-MalwareAssessment -Remove
  } catch {
    Write-Err ("MalwarePersistence apply failed: {0}" -f $_.Exception.Message)
    return (New-ModuleResult -Name $script:ModuleName -Status 'Failed' -Message ('Apply error: ' + $_.Exception.Message))
  }

  $message = Get-ResultSummary -Result $result
  return (New-ModuleResult -Name $script:ModuleName -Status 'Succeeded' -Message $message)
}

Export-ModuleMember -Function Test-Ready,Invoke-Verify,Invoke-Apply
